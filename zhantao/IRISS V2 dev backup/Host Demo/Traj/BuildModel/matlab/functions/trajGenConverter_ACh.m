function trajGenConverter_ACh(SDIR, MDIR, SCAN_NO_ACh)
%trajGenConverter 2021-09-07 MJG 
%   This code loads the saved params .mat file and (attempts to) convert
%   those variables to the values that Martin's traj gen code requires
%   This is specifically for the ACh; it will save EyeModel_cornea.mat to
%   the directory specified by MDIR 

% load the ACh params, generated by process_ACh.m 
load([SDIR 'params_ACh_' num2str(SCAN_NO_ACh,'%04i') '.mat'], ...
    'endo_pts_mm', 'iris_pts_mm', 'OCTz_ACh', 'TOI_ACh', ...
    'pupilCenter', 'pupilRadius', 'corneaThickness', 'refIndex');
% not using: opticalCenter, corn_pts_mm, pupil_pts_mm

% change notation
TOI = TOI_ACh;

% --- adjust notation, etc. to get everything into the format that Martin's
% code expects 

% > Center_cornea_IRISSframe
% a 3x1 array of doubles; indicates the intersection of the pupil circle
% fit with the optical path line; == center of pupil
Center_cornea_IRISSframe = inv(TOI) * [pupilCenter; 1]; % transform to {I} % 2021-09-09 Mia 
Center_cornea_IRISSframe = Center_cornea_IRISSframe(1:3); % strip off xyz

% > IrisEllipseAxis_cornea_IRISSframe
% a 2x2 defined as:
% IrisEllipseAxis_cornea_IRISSframe = [1/Radius_IRISSframe^2 0; 0 1/Radius_IRISSframe^2]
% where Radius_IRISSframe = rn * 0.88*scale_OCT2IRISS;
% and rn is the pupil radius (in {OCT})
% the 0.88 is refIndex scaling and scale_OCT2IRISS is always ~= 1 (so we
% ignore it)
IrisEllipseAxis_cornea_IRISSframe = diag([1 1]) * 1/(refIndex*pupilRadius)^2;

% > PolyCoef_cornea_mm_IRISSframe
% PolyCoef_cornea_mm_IRISSframe = PolyCoef_mm_IRISSframe;
% PolyCoef_mm_IRISSframe = [fit_IRISS.p00 fit_IRISS.p10 fit_IRISS.p01 fit_IRISS.p20 fit_IRISS.p11 fit_IRISS.p02];
% where fit_IRISS are the coefficients of the poly22 surface fit (to the
% cornea), in the {IRISS} frame
% Note: the surface fit will produce different results depending on which
% frame it is done in; so we have to convert the orig pts and redo the fit
% in the {IRISS} frame. 
% transform from {OCT} into {IRISS}
endoXYZ_IRISS = [endo_pts_mm ones(size(endo_pts_mm,1),1)] * inv(TOI)';
% redo the fit in the {I} frame 
sfIRISS = fit([endoXYZ_IRISS(:,1), endoXYZ_IRISS(:,2)], endoXYZ_IRISS(:,3), 'poly22');
% now feed it what it wants...
PolyCoef_cornea_mm_IRISSframe = [sfIRISS.p00 sfIRISS.p10 sfIRISS.p01 sfIRISS.p20 sfIRISS.p11 sfIRISS.p02];

% > IrisPlane_cornea_mm_IRISSframe = IrisPlane_IRISSframe;
% this one is easy: it's a 4x1 where the first 3 elems are [0 0 1]' and the
% fourth element is the "iris_depth"; CW used the average of all the iris
% fitting points, but we can do much better and use the actual found
% center as a measure of "iris depth"; this value was already calculated,
% above as Center_cornea_IRISSframe(3), so:
IrisPlane_cornea_mm_IRISSframe = [0 0 1 Center_cornea_IRISSframe(3)]';

% > XYZ_mm_IRISSframe_cornea 
% calculated as: 
% XYZ_mm_IRISSframe_cornea = XYZ_mm_IRISSframe_backup;
% XYZ_mm_IRISSframe_backup = temp4(:,1:3);
% temp4 = [XYZ_mm_backup ones(size(XYZ_mm_backup,1),1)] * inv(TOI)';
% where iris_pts_mm are the iris pts in [mm] in {OCT}
% so let's convert our iris_xyz_mm pts to the IRISS frame...
tempIrisPts = [iris_pts_mm ones(size(iris_pts_mm,1),1)] * inv(TOI)';
XYZ_mm_IRISSframe_cornea = tempIrisPts(:,1:3);

% > FX_IRISS, etc.
% these are the triangulation mesh points for the endo surface fit 
% first calculate x and y range in {IRISS} frame...
[FX_IRISS, FY_IRISS] = meshgrid(min(endoXYZ_IRISS(:,1)):.1:max(endoXYZ_IRISS(:,1)), min(endoXYZ_IRISS(:,2)):.1:max(endoXYZ_IRISS(:,2)));
% reshape into what Martin's code expects
FX_IRISS = reshape(FX_IRISS,[size(FX_IRISS,1)*size(FX_IRISS,2) 1]);
FY_IRISS = reshape(FY_IRISS,[size(FY_IRISS,1)*size(FY_IRISS,2) 1]);
% then eval surf fit at each value of x and y 
FZ_IRISS = feval(sfIRISS, [FX_IRISS, FY_IRISS]);

% > the last vars are very easy, they are: 
% this was calculated in postprocess_cornea() within process_ACh
Thickness_cornea_mm = corneaThickness; 
TIO_cornea = inv(TOI);
OCTprobeZ_cornea = OCTz_ACh; % just notation change
SurfacePolyOrd = 2; % this is always constant

% now can save as the .mat file that Martin's code expects... 
% create unique filename 
timestamp = datestr(now,'YYYY-mm-DD_HHMMSSFFF');
% save this model data as a unique filename 
save([MDIR 'EyeModel_cornea_' timestamp '.mat'], ...
    'OCTprobeZ_cornea', ... % 
    'TIO_cornea', ... % 
    'Center_cornea_IRISSframe', ... % 
    'IrisEllipseAxis_cornea_IRISSframe', ... %
    'PolyCoef_cornea_mm_IRISSframe', ... %
    'SurfacePolyOrd', ... % 
    'IrisPlane_cornea_mm_IRISSframe', ... %
    'Thickness_cornea_mm', ... %
    'XYZ_mm_IRISSframe_cornea', ... %
    'FX_IRISS', 'FY_IRISS', 'FZ_IRISS',...
    'sfIRISS'); % Mia 2021-09-09

% then make a copy of this file and save the copy as 'EyeModel_cornea.mat',
% overwriting any previous model that's in the directory...
copyfile([MDIR 'EyeModel_cornea_' timestamp '.mat'], [MDIR 'EyeModel_cornea.mat']);




end

